//
// Generated by Bluespec Compiler
//
//
// Ports:
// Name                         I/O  size props
// result_valid                   O     1
// result_quo                     O    32 reg
// result_rem                     O    32 reg
// RDY_result_rem                 O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// start_num_is_signed            I     1 reg
// start_den_is_signed            I     1 reg
// start_num                      I    32
// start_den                      I    32
// EN_start                       I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkIntDiv_32(CLK,
		   RST_N,

		   start_num_is_signed,
		   start_den_is_signed,
		   start_num,
		   start_den,
		   EN_start,

		   result_valid,

		   result_quo,

		   result_rem,
		   RDY_result_rem);
  input  CLK;
  input  RST_N;

  // action method start
  input  start_num_is_signed;
  input  start_den_is_signed;
  input  [31 : 0] start_num;
  input  [31 : 0] start_den;
  input  EN_start;

  // value method result_valid
  output result_valid;

  // value method result_quo
  output [31 : 0] result_quo;

  // value method result_rem
  output [31 : 0] result_rem;
  output RDY_result_rem;

  // signals for module outputs
  wire [31 : 0] result_quo, result_rem;
  wire RDY_result_rem, result_valid;

  // register m_rg_denom
  reg [31 : 0] m_rg_denom;
  wire [31 : 0] m_rg_denom$D_IN;
  wire m_rg_denom$EN;

  // register m_rg_denom2
  reg [31 : 0] m_rg_denom2;
  reg [31 : 0] m_rg_denom2$D_IN;
  wire m_rg_denom2$EN;

  // register m_rg_denom_is_signed
  reg m_rg_denom_is_signed;
  wire m_rg_denom_is_signed$D_IN, m_rg_denom_is_signed$EN;

  // register m_rg_n
  reg [31 : 0] m_rg_n;
  reg [31 : 0] m_rg_n$D_IN;
  wire m_rg_n$EN;

  // register m_rg_numer
  reg [31 : 0] m_rg_numer;
  reg [31 : 0] m_rg_numer$D_IN;
  wire m_rg_numer$EN;

  // register m_rg_numer_is_signed
  reg m_rg_numer_is_signed;
  wire m_rg_numer_is_signed$D_IN, m_rg_numer_is_signed$EN;

  // register m_rg_quo
  reg [31 : 0] m_rg_quo;
  reg [31 : 0] m_rg_quo$D_IN;
  wire m_rg_quo$EN;

  // register m_rg_quoIsNeg
  reg m_rg_quoIsNeg;
  wire m_rg_quoIsNeg$D_IN, m_rg_quoIsNeg$EN;

  // register m_rg_remIsNeg
  reg m_rg_remIsNeg;
  wire m_rg_remIsNeg$D_IN, m_rg_remIsNeg$EN;

  // register m_rg_state
  reg [2 : 0] m_rg_state;
  reg [2 : 0] m_rg_state$D_IN;
  wire m_rg_state$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_m_rl_start_div_by_zero,
       WILL_FIRE_RL_m_rl_start_overflow,
       WILL_FIRE_RL_m_rl_start_s;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_m_rg_denom$write_1__VAL_2,
		MUX_m_rg_denom2$write_1__VAL_1,
		MUX_m_rg_denom2$write_1__VAL_2,
		MUX_m_rg_n$write_1__VAL_1,
		MUX_m_rg_n$write_1__VAL_2,
		MUX_m_rg_numer$write_1__VAL_2,
		MUX_m_rg_numer$write_1__VAL_3,
		MUX_m_rg_quo$write_1__VAL_1;
  wire MUX_m_rg_denom2$write_1__SEL_1,
       MUX_m_rg_denom2$write_1__SEL_2,
       MUX_m_rg_numer$write_1__SEL_2,
       MUX_m_rg_quo$write_1__SEL_1,
       MUX_m_rg_state$write_1__SEL_3,
       MUX_m_rg_state$write_1__SEL_4;

  // remaining internal signals
  wire [31 : 0] _theResult___fst__h631,
		_theResult___snd_fst__h626,
		denom___1__h564,
		numer___1__h563,
		x__h2520,
		x__h2624,
		x__h2683,
		x__h2698,
		y__h2379;
  wire IF_m_rg_numer_is_signed_THEN_m_rg_numer_BIT_31_ETC___d39,
       m_rg_denom2_4_ULE_0_CONCAT_m_rg_numer_BITS_31__ETC___d47,
       m_rg_numer_ULT_m_rg_denom2_4___d59,
       m_rg_numer_ULT_m_rg_denom___d55;

  // value method result_valid
  assign result_valid = m_rg_state == 3'd4 ;

  // value method result_quo
  assign result_quo = m_rg_quo ;

  // value method result_rem
  assign result_rem = m_rg_numer ;
  assign RDY_result_rem = 1'd1 ;

  // rule RL_m_rl_start_div_by_zero
  assign WILL_FIRE_RL_m_rl_start_div_by_zero =
	     m_rg_state == 3'd1 && m_rg_denom == 32'd0 ;

  // rule RL_m_rl_start_overflow
  assign WILL_FIRE_RL_m_rl_start_overflow =
	     m_rg_state == 3'd1 && m_rg_numer_is_signed &&
	     m_rg_numer == 32'h80000000 &&
	     m_rg_denom_is_signed &&
	     m_rg_denom == 32'hFFFFFFFF ;

  // rule RL_m_rl_start_s
  assign WILL_FIRE_RL_m_rl_start_s =
	     m_rg_state == 3'd1 && m_rg_denom != 32'd0 &&
	     (!m_rg_numer_is_signed || m_rg_numer != 32'h80000000 ||
	      !m_rg_denom_is_signed ||
	      m_rg_denom != 32'hFFFFFFFF) ;

  // inputs to muxes for submodule ports
  assign MUX_m_rg_denom2$write_1__SEL_1 =
	     m_rg_state == 3'd2 &&
	     m_rg_denom2_4_ULE_0_CONCAT_m_rg_numer_BITS_31__ETC___d47 ;
  assign MUX_m_rg_denom2$write_1__SEL_2 =
	     m_rg_state == 3'd3 && !m_rg_numer_ULT_m_rg_denom___d55 &&
	     m_rg_numer_ULT_m_rg_denom2_4___d59 ;
  assign MUX_m_rg_numer$write_1__SEL_2 =
	     m_rg_state == 3'd3 &&
	     (m_rg_numer_ULT_m_rg_denom___d55 && m_rg_remIsNeg ||
	      !m_rg_numer_ULT_m_rg_denom___d55 &&
	      !m_rg_numer_ULT_m_rg_denom2_4___d59) ;
  assign MUX_m_rg_quo$write_1__SEL_1 =
	     m_rg_state == 3'd3 &&
	     (m_rg_numer_ULT_m_rg_denom___d55 && m_rg_quoIsNeg ||
	      !m_rg_numer_ULT_m_rg_denom___d55 &&
	      !m_rg_numer_ULT_m_rg_denom2_4___d59) ;
  assign MUX_m_rg_state$write_1__SEL_3 =
	     m_rg_state == 3'd3 && m_rg_numer_ULT_m_rg_denom___d55 ;
  assign MUX_m_rg_state$write_1__SEL_4 =
	     m_rg_state == 3'd2 &&
	     !m_rg_denom2_4_ULE_0_CONCAT_m_rg_numer_BITS_31__ETC___d47 ;
  assign MUX_m_rg_denom$write_1__VAL_2 =
	     (m_rg_numer_is_signed && m_rg_denom_is_signed) ?
	       denom___1__h564 :
	       _theResult___snd_fst__h626 ;
  assign MUX_m_rg_denom2$write_1__VAL_1 = { m_rg_denom2[30:0], 1'd0 } ;
  assign MUX_m_rg_denom2$write_1__VAL_2 = { 1'd0, m_rg_denom2[31:1] } ;
  assign MUX_m_rg_n$write_1__VAL_1 = { m_rg_n[30:0], 1'd0 } ;
  assign MUX_m_rg_n$write_1__VAL_2 = { 1'd0, m_rg_n[31:1] } ;
  assign MUX_m_rg_numer$write_1__VAL_2 =
	     m_rg_numer_ULT_m_rg_denom___d55 ? x__h2683 : x__h2520 ;
  assign MUX_m_rg_numer$write_1__VAL_3 =
	     m_rg_numer_is_signed ? numer___1__h563 : m_rg_numer ;
  assign MUX_m_rg_quo$write_1__VAL_1 =
	     m_rg_numer_ULT_m_rg_denom___d55 ? x__h2624 : x__h2698 ;

  // register m_rg_denom
  assign m_rg_denom$D_IN =
	     EN_start ? start_den : MUX_m_rg_denom$write_1__VAL_2 ;
  assign m_rg_denom$EN = EN_start || WILL_FIRE_RL_m_rl_start_s ;

  // register m_rg_denom2
  always@(MUX_m_rg_denom2$write_1__SEL_1 or
	  MUX_m_rg_denom2$write_1__VAL_1 or
	  MUX_m_rg_denom2$write_1__SEL_2 or
	  MUX_m_rg_denom2$write_1__VAL_2 or
	  WILL_FIRE_RL_m_rl_start_s or MUX_m_rg_denom$write_1__VAL_2)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_m_rg_denom2$write_1__SEL_1:
	  m_rg_denom2$D_IN = MUX_m_rg_denom2$write_1__VAL_1;
      MUX_m_rg_denom2$write_1__SEL_2:
	  m_rg_denom2$D_IN = MUX_m_rg_denom2$write_1__VAL_2;
      WILL_FIRE_RL_m_rl_start_s:
	  m_rg_denom2$D_IN = MUX_m_rg_denom$write_1__VAL_2;
      default: m_rg_denom2$D_IN = 32'hAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign m_rg_denom2$EN =
	     m_rg_state == 3'd2 &&
	     m_rg_denom2_4_ULE_0_CONCAT_m_rg_numer_BITS_31__ETC___d47 ||
	     m_rg_state == 3'd3 && !m_rg_numer_ULT_m_rg_denom___d55 &&
	     m_rg_numer_ULT_m_rg_denom2_4___d59 ||
	     WILL_FIRE_RL_m_rl_start_s ;

  // register m_rg_denom_is_signed
  assign m_rg_denom_is_signed$D_IN = start_den_is_signed ;
  assign m_rg_denom_is_signed$EN = EN_start ;

  // register m_rg_n
  always@(MUX_m_rg_denom2$write_1__SEL_1 or
	  MUX_m_rg_n$write_1__VAL_1 or
	  MUX_m_rg_denom2$write_1__SEL_2 or
	  MUX_m_rg_n$write_1__VAL_2 or WILL_FIRE_RL_m_rl_start_s)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_m_rg_denom2$write_1__SEL_1: m_rg_n$D_IN = MUX_m_rg_n$write_1__VAL_1;
      MUX_m_rg_denom2$write_1__SEL_2: m_rg_n$D_IN = MUX_m_rg_n$write_1__VAL_2;
      WILL_FIRE_RL_m_rl_start_s: m_rg_n$D_IN = 32'd1;
      default: m_rg_n$D_IN = 32'hAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign m_rg_n$EN =
	     m_rg_state == 3'd2 &&
	     m_rg_denom2_4_ULE_0_CONCAT_m_rg_numer_BITS_31__ETC___d47 ||
	     m_rg_state == 3'd3 && !m_rg_numer_ULT_m_rg_denom___d55 &&
	     m_rg_numer_ULT_m_rg_denom2_4___d59 ||
	     WILL_FIRE_RL_m_rl_start_s ;

  // register m_rg_numer
  always@(EN_start or
	  start_num or
	  MUX_m_rg_numer$write_1__SEL_2 or
	  MUX_m_rg_numer$write_1__VAL_2 or
	  WILL_FIRE_RL_m_rl_start_s or
	  MUX_m_rg_numer$write_1__VAL_3 or WILL_FIRE_RL_m_rl_start_overflow)
  case (1'b1)
    EN_start: m_rg_numer$D_IN = start_num;
    MUX_m_rg_numer$write_1__SEL_2:
	m_rg_numer$D_IN = MUX_m_rg_numer$write_1__VAL_2;
    WILL_FIRE_RL_m_rl_start_s:
	m_rg_numer$D_IN = MUX_m_rg_numer$write_1__VAL_3;
    WILL_FIRE_RL_m_rl_start_overflow: m_rg_numer$D_IN = 32'd0;
    default: m_rg_numer$D_IN = 32'hAAAAAAAA /* unspecified value */ ;
  endcase
  assign m_rg_numer$EN =
	     MUX_m_rg_numer$write_1__SEL_2 || EN_start ||
	     WILL_FIRE_RL_m_rl_start_s ||
	     WILL_FIRE_RL_m_rl_start_overflow ;

  // register m_rg_numer_is_signed
  assign m_rg_numer_is_signed$D_IN = start_num_is_signed ;
  assign m_rg_numer_is_signed$EN = EN_start ;

  // register m_rg_quo
  always@(MUX_m_rg_quo$write_1__SEL_1 or
	  MUX_m_rg_quo$write_1__VAL_1 or
	  WILL_FIRE_RL_m_rl_start_overflow or
	  m_rg_numer or
	  WILL_FIRE_RL_m_rl_start_s or WILL_FIRE_RL_m_rl_start_div_by_zero)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_m_rg_quo$write_1__SEL_1:
	  m_rg_quo$D_IN = MUX_m_rg_quo$write_1__VAL_1;
      WILL_FIRE_RL_m_rl_start_overflow: m_rg_quo$D_IN = m_rg_numer;
      WILL_FIRE_RL_m_rl_start_s: m_rg_quo$D_IN = 32'd0;
      WILL_FIRE_RL_m_rl_start_div_by_zero: m_rg_quo$D_IN = 32'hFFFFFFFF;
      default: m_rg_quo$D_IN = 32'hAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign m_rg_quo$EN =
	     MUX_m_rg_quo$write_1__SEL_1 ||
	     WILL_FIRE_RL_m_rl_start_overflow ||
	     WILL_FIRE_RL_m_rl_start_s ||
	     WILL_FIRE_RL_m_rl_start_div_by_zero ;

  // register m_rg_quoIsNeg
  assign m_rg_quoIsNeg$D_IN =
	     (m_rg_numer_is_signed && m_rg_denom_is_signed) ?
	       m_rg_numer[31] != m_rg_denom[31] :
	       IF_m_rg_numer_is_signed_THEN_m_rg_numer_BIT_31_ETC___d39 ;
  assign m_rg_quoIsNeg$EN = WILL_FIRE_RL_m_rl_start_s ;

  // register m_rg_remIsNeg
  assign m_rg_remIsNeg$D_IN =
	     (m_rg_numer_is_signed && m_rg_denom_is_signed) ?
	       m_rg_numer[31] :
	       m_rg_numer_is_signed && m_rg_numer[31] ;
  assign m_rg_remIsNeg$EN = WILL_FIRE_RL_m_rl_start_s ;

  // register m_rg_state
  always@(EN_start or
	  m_rg_state or
	  MUX_m_rg_state$write_1__SEL_3 or
	  MUX_m_rg_state$write_1__SEL_4 or
	  WILL_FIRE_RL_m_rl_start_s or
	  WILL_FIRE_RL_m_rl_start_overflow or
	  WILL_FIRE_RL_m_rl_start_div_by_zero)
  case (1'b1)
    EN_start: m_rg_state$D_IN = 3'd1;
    m_rg_state == 3'd4: m_rg_state$D_IN = 3'd5;
    MUX_m_rg_state$write_1__SEL_3: m_rg_state$D_IN = 3'd4;
    MUX_m_rg_state$write_1__SEL_4: m_rg_state$D_IN = 3'd3;
    WILL_FIRE_RL_m_rl_start_s: m_rg_state$D_IN = 3'd2;
    WILL_FIRE_RL_m_rl_start_overflow || WILL_FIRE_RL_m_rl_start_div_by_zero:
	m_rg_state$D_IN = 3'd4;
    default: m_rg_state$D_IN = 3'b010 /* unspecified value */ ;
  endcase
  assign m_rg_state$EN =
	     m_rg_state == 3'd3 && m_rg_numer_ULT_m_rg_denom___d55 ||
	     m_rg_state == 3'd2 &&
	     !m_rg_denom2_4_ULE_0_CONCAT_m_rg_numer_BITS_31__ETC___d47 ||
	     EN_start ||
	     WILL_FIRE_RL_m_rl_start_s ||
	     WILL_FIRE_RL_m_rl_start_overflow ||
	     WILL_FIRE_RL_m_rl_start_div_by_zero ||
	     m_rg_state == 3'd4 ;

  // remaining internal signals
  assign IF_m_rg_numer_is_signed_THEN_m_rg_numer_BIT_31_ETC___d39 =
	     m_rg_numer_is_signed ?
	       m_rg_numer[31] :
	       m_rg_denom_is_signed && m_rg_denom[31] ;
  assign _theResult___fst__h631 =
	     m_rg_denom_is_signed ? denom___1__h564 : m_rg_denom ;
  assign _theResult___snd_fst__h626 =
	     m_rg_numer_is_signed ? m_rg_denom : _theResult___fst__h631 ;
  assign denom___1__h564 = m_rg_denom[31] ? -m_rg_denom : m_rg_denom ;
  assign m_rg_denom2_4_ULE_0_CONCAT_m_rg_numer_BITS_31__ETC___d47 =
	     m_rg_denom2 <= y__h2379 ;
  assign m_rg_numer_ULT_m_rg_denom2_4___d59 = m_rg_numer < m_rg_denom2 ;
  assign m_rg_numer_ULT_m_rg_denom___d55 = m_rg_numer < m_rg_denom ;
  assign numer___1__h563 = m_rg_numer[31] ? x__h2683 : m_rg_numer ;
  assign x__h2520 = m_rg_numer - m_rg_denom2 ;
  assign x__h2624 = -m_rg_quo ;
  assign x__h2683 = -m_rg_numer ;
  assign x__h2698 = m_rg_quo + m_rg_n ;
  assign y__h2379 = { 1'd0, m_rg_numer[31:1] } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        m_rg_state <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (m_rg_state$EN)
	  m_rg_state <= `BSV_ASSIGNMENT_DELAY m_rg_state$D_IN;
      end
    if (m_rg_denom$EN) m_rg_denom <= `BSV_ASSIGNMENT_DELAY m_rg_denom$D_IN;
    if (m_rg_denom2$EN) m_rg_denom2 <= `BSV_ASSIGNMENT_DELAY m_rg_denom2$D_IN;
    if (m_rg_denom_is_signed$EN)
      m_rg_denom_is_signed <= `BSV_ASSIGNMENT_DELAY m_rg_denom_is_signed$D_IN;
    if (m_rg_n$EN) m_rg_n <= `BSV_ASSIGNMENT_DELAY m_rg_n$D_IN;
    if (m_rg_numer$EN) m_rg_numer <= `BSV_ASSIGNMENT_DELAY m_rg_numer$D_IN;
    if (m_rg_numer_is_signed$EN)
      m_rg_numer_is_signed <= `BSV_ASSIGNMENT_DELAY m_rg_numer_is_signed$D_IN;
    if (m_rg_quo$EN) m_rg_quo <= `BSV_ASSIGNMENT_DELAY m_rg_quo$D_IN;
    if (m_rg_quoIsNeg$EN)
      m_rg_quoIsNeg <= `BSV_ASSIGNMENT_DELAY m_rg_quoIsNeg$D_IN;
    if (m_rg_remIsNeg$EN)
      m_rg_remIsNeg <= `BSV_ASSIGNMENT_DELAY m_rg_remIsNeg$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    m_rg_denom = 32'hAAAAAAAA;
    m_rg_denom2 = 32'hAAAAAAAA;
    m_rg_denom_is_signed = 1'h0;
    m_rg_n = 32'hAAAAAAAA;
    m_rg_numer = 32'hAAAAAAAA;
    m_rg_numer_is_signed = 1'h0;
    m_rg_quo = 32'hAAAAAAAA;
    m_rg_quoIsNeg = 1'h0;
    m_rg_remIsNeg = 1'h0;
    m_rg_state = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkIntDiv_32

